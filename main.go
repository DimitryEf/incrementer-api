/*
Задача для SWE (Golang)
Нужно написать серверное приложение, с RPC API. Первый метод API -- GetNumber, он возвращает число.
Сначала это число -- ноль. Второй метод API -- IncrementNumber, он инкрементирует это число так,
что при следующем вызове GetNumber вернет на единицу больше. Третий метод SetParams -- метод настроек.
Настройки нужно сделать следующие:
Размер инкремента (чтобы увеличивалось не на один, а на два, три или тысячу). Размер инкремента
должен быть положительным.
Размер верхней границы. Если я поставлю ее 1000, то при доинкременчивании до 1000 число сбрасывается
на ноль само.

Число и настройки должны переживать перезапуск приложения: если я доинкрементил до 10, то
при следующем запуске сервера GetNumber должно сразу возвращать 10, т.е. должно быть персистентное хранилище.
В качестве хранилища должна быть любая OS БД, способная пережить выключение питания сервера,
но не просто файл, так как файл не позволит наращивать функционал приложения.
К приложению должен быть приложен docker-compose.yml файл для развертывания системы локально.

Т.е. приложение очень простое. А теперь сложность: оно должно быть сделано очень хорошо.
Т.е. максимально качественно, как только можно. Код должен быть идеальным,
все должно быть покрыто unit и интеграционными тестами.
Unit-тесты на логику приложения (RPC-хэндлеры и внутренние компоненты).
Интеграционные тесты должны быть на бинарник сервера в условиях,
приближенных к боевым (с реальными инстансами БД, заполненными тестовыми данными и тому подобное).
Тесты должны быть герметичными, т.е. поднимать окружение, пускать тесты и чистить за собой все сами.
Код должен быть разбит на компоненты, т.е. по всем правилам хорошей архитектуры.
Все публичные типы и методы должны быть полностью покрыты понятной (т.е. полезной, а не для отписки)
документацией. В общем, нужно сделать такой код, который каждый разработчик мечтает
получить на поддержку -- идеальный (насколько кандидат способен).

Обратить внимание на:
Форматирование кода.
Нэйминг (названия всех сущностей).
Обработку ошибок и понятные ошибки, возвращаемые API.
Покрытие unit и интеграционными тестами (в том числе, ошибочных ситуаций).
Наличие документации.
Разделение логики сервиса и инфраструктуры сервера.
Полезные логи сервера.
Модульность (с использованием Dependency Injection).
DRY (включая использование качественных Open Source библиотек).
Общая читабельность и простота кода.
Отсутствие переусложнения. Хороший код != сложная, навороченная архитектура. Сложность ревью кода -- большой минус.
*/

package main

//TODO Сделать DI руками, сделать тесты, а уже потом юзать уберовский dig
//https://gitlab.com/drewolson/go_di_example/-/blob/master/example.go

//TODO переделать после ручных тестов на gRPC

func main() {
	logger := NewLogger()
	config := NewConfig(logger)
	db, err := NewDbConnection(config)
	if err != nil {
		logger.Log.Fatal(err)
	}
	repo := NewPostgresRepo(db)
	inc := NewIncrementer(repo)
	api := NewGrpcApi(inc)
	server := NewGrpcServer(config, api)
	go server.Run()
	server.ReadyToStop()

}

/*func CatchSIG(config *Config, server *Server) {
	interrupt := make(chan os.Signal, 1)
	signal.Notify(interrupt, os.Interrupt, syscall.SIGTERM) // Отлавливаем в канал interrupt сигналы os.Interrupt и syscall.SIGTERM

	<-interrupt // Здесь исполнение кода блокируется, пока не не будет получен сигнал ОС

	config.Log.Log.Info("Stopping server...")

	//Устанавливаем контекст с таймаутом для принудительного завершения работы сервера
	timeout, cancelFunc := context.WithTimeout(context.Background(), m.ShutdownTimeout)
	defer cancelFunc()
	err := server.HttpServer.Shutdown(timeout) // Функция Shutdown стандартного пакета http обеспечивает graceful shutdown
	if err != nil {
		log.Fatal(err)
	}

	config.Log.Log.Info("The server stopped.")
}*/

/*
Задача для SWE (Golang)
Нужно написать серверное приложение, с RPC API. Первый метод API -- GetNumber, он возвращает число.
Сначала это число -- ноль. Второй метод API -- IncrementNumber, он инкрементирует это число так,
что при следующем вызове GetNumber вернет на единицу больше. Третий метод SetParams -- метод настроек.
Настройки нужно сделать следующие:
Размер инкремента (чтобы увеличивалось не на один, а на два, три или тысячу). Размер инкремента
должен быть положительным.
Размер верхней границы. Если я поставлю ее 1000, то при доинкременчивании до 1000 число сбрасывается
на ноль само.

Число и настройки должны переживать перезапуск приложения: если я доинкрементил до 10, то
при следующем запуске сервера GetNumber должно сразу возвращать 10, т.е. должно быть персистентное хранилище.
В качестве хранилища должна быть любая OS БД, способная пережить выключение питания сервера,
но не просто файл, так как файл не позволит наращивать функционал приложения.
К приложению должен быть приложен docker-compose.yml файл для развертывания системы локально.

Т.е. приложение очень простое. А теперь сложность: оно должно быть сделано очень хорошо.
Т.е. максимально качественно, как только можно. Код должен быть идеальным,
все должно быть покрыто unit и интеграционными тестами.
Unit-тесты на логику приложения (RPC-хэндлеры и внутренние компоненты).
Интеграционные тесты должны быть на бинарник сервера в условиях,
приближенных к боевым (с реальными инстансами БД, заполненными тестовыми данными и тому подобное).
Тесты должны быть герметичными, т.е. поднимать окружение, пускать тесты и чистить за собой все сами.
Код должен быть разбит на компоненты, т.е. по всем правилам хорошей архитектуры.
Все публичные типы и методы должны быть полностью покрыты понятной (т.е. полезной, а не для отписки)
документацией. В общем, нужно сделать такой код, который каждый разработчик мечтает
получить на поддержку -- идеальный (насколько кандидат способен).

Обратить внимание на:
Форматирование кода.
Нэйминг (названия всех сущностей).
Обработку ошибок и понятные ошибки, возвращаемые API.
Покрытие unit и интеграционными тестами (в том числе, ошибочных ситуаций).
Наличие документации.
Разделение логики сервиса и инфраструктуры сервера.
Полезные логи сервера.
Модульность (с использованием Dependency Injection).
DRY (включая использование качественных Open Source библиотек).
Общая читабельность и простота кода.
Отсутствие переусложнения. Хороший код != сложная, навороченная архитектура. Сложность ревью кода -- большой минус.
*/
package main

//TODO Сделать DI руками, сделать тесты, а уже потом юзать уберовский dig
//https://gitlab.com/drewolson/go_di_example/-/blob/master/example.go

//TODO переделать после ручных тестов на gRPC

//protoc --go_out=plugins=grpc:. incrementer.proto

import "github.com/DimitryEf/incrementer-api/container"

func main() {

	// Запуск приложения
	container.Execute()
}
